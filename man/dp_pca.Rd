% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dp_pca.R
\name{dp_pca}
\alias{dp_pca}
\title{Differentially Private PCA}
\usage{
dp_pca(
  X,
  center = TRUE,
  scale. = FALSE,
  axes = c(1, 2),
  dp = FALSE,
  eps = NULL,
  delta = NULL,
  cpp.option = TRUE
)
}
\arguments{
\item{X}{A numeric matrix or an object coercible to a matrix with
\eqn{n} rows (observations) and \eqn{p} columns (variables).}

\item{center}{Logical; should the variables be centered before PCA?
Passed to \code{scale()}.}

\item{scale.}{Logical; should the variables be scaled to unit variance?
Passed to \code{scale()}.}

\item{axes}{Integer vector indicating which principal components to return
(e.g., \code{c(1, 2)} for the first two PCs). The maximum index in
\code{axes} must not exceed the number of variables \code{p}.}

\item{dp}{Logical; if \code{TRUE}, perform differentially private PCA using
a tau-spherical mechanism applied to the empirical covariance/kernel.}

\item{eps}{Privacy budget \eqn{\varepsilon} to be used when \code{dp = TRUE}.
Must be strictly positive.}

\item{delta}{Privacy parameter \eqn{\delta} to be used when \code{dp = TRUE}.
Must satisfy \eqn{0 < \delta < 1}.}

\item{cpp.option}{Logical; if \code{TRUE}, use the C++ implementation inside
\code{mech_tau_sph()} when available, otherwise use a pure R version.}
}
\value{
A list with the following components:
\itemize{
\item \code{X_pca}: An \eqn{n \times |\mathrm{axes}|} matrix of PCA scores
for the requested components (PC axes).
\item \code{loadings}: A \eqn{p \times |\mathrm{axes}|} matrix of loadings
(eigenvectors) corresponding to the selected components.
\item \code{eigvals}: A numeric vector of the selected eigenvalues.
\item \code{dp}: Logical flag indicating whether DP-PCA was used.
\item \code{eps}: Privacy budget \eqn{\varepsilon} (only for \code{dp = TRUE}).
\item \code{delta}: Privacy parameter \eqn{\delta} (only for \code{dp = TRUE}).
\item \code{sigma}: Noise scale used in the tau-spherical mechanism
(only for \code{dp = TRUE}).
}
}
\description{
Performs (optionally differentially private) principal component analysis (PCA)
on a numeric data matrix. When \code{dp = TRUE}, a tau-spherical DP mechanism
is applied to the (scaled) data before computing the eigendecomposition.
}
\details{
The data matrix \code{X} is first centered and/or scaled using \code{scale()}
according to \code{center} and \code{scale.}. For the non-DP case
(\code{dp = FALSE}), the empirical Gram matrix \eqn{G = X^\top X} is formed,
and the leading eigenvalues/eigenvectors are obtained via
\code{rARPACK::eigs_sym()}.

For the DP case (\code{dp = TRUE}), a Gaussian noise level
\code{sig_sph} is computed from \code{eps} and \code{delta}, and the
tau-spherical mechanism \code{mech_tau_sph()} is applied to the processed
data \code{X_proc} to obtain a privatized kernel \code{tilde_Ksph}. The
leading eigenvalues/eigenvectors of this privatized kernel are then used to
construct differentially private scores and loadings.
}
\seealso{
\code{\link{dp_score_plot}}, \code{\link{dp_score_plot_group}}
}
